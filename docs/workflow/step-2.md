# Step 2: 커밋 시퀀스(작업 계획) 작성 요청
이 단계는 `/plan/motivation.md`를 달성하기 위한 구체적인 **커밋 단위 작업 계획**을 수립하는 단계입니다.
- 상세한 구현 로직(엣지 케이스 등)보다는 **전체적인 작업 흐름과 커밋 순서**를 확정하는 것이 목표입니다.
- AI가 구현할 때 **작은 단위로, 순차적으로** 진행할 수 있도록 로드맵을 그려주세요.
- 작은 커밋을 순서 잘 맞춰서 쌓아야 리뷰하기도 편합니다.

# 참고 자료
1. [background.md](./background.md)
- `/plan/motivation.md` (Step 1에서 생성됨)
- [기획서 링크]
- [피그마 링크]
- [회의 음성 텍스트 요약본]
- [관련 필기]
- [간단한 개발설계]

# 요청 내용
앞서 작성한 `/plan/motivation.md`의 목표를 달성하기 위해,

**작업 순서가 보장된 커밋 목록**을 `/plan/commit-sequence.md`에 작성해주세요.

## 작성 양식 (`/plan/commit-sequence.md`)
**형식**:
> - [커밋 타입]: 커밋 메시지 (3줄 미만 요약)
>   - 상세 작업 내용 1
>   - 상세 작업 내용 2

## 작업 순서 가이드 (Thinking Process)
저는 충돌을 방지하고 리뷰 효율을 높이기 위해 아래의 **6단계 프로세스**를 선호합니다.

커밋 계획 작성 시 아래 흐름을 따라주세요.

### Phase 0. 사전 작업 (Conflict 방지)
**1. 레거시 처리 (`deprecated`)**
- 기존 모듈을 대체해야 한다면, 바로 삭제하지 말고 `@deprecated` 처리부터 먼저 커밋합니다.
- 방법: 모듈명에 `Deprecated` 접두사 추가, JSDoc에 `@deprecated` 명시.

```typescript
/**
 * @deprecated 이런 이유로 앞으로 사용되지 않으며, [파일 경로]/[파일명] 모듈을 대신 사용해야합니다.
 */
function deprecatedSomeFunction() {}
```

**2. 기존 코드 리팩토링**
- 기존 함수나 컴포넌트의 구조 변경(파라미터 타입 변경 등)이 필요하다면, 새 기능 구현 전에 먼저 수정합니다.
- **이유**: 기능 구현 후 나중에 기존 코드를 건드리면 Rebase 시 충돌(Conflict)이 심하게 발생합니다.
    ```typescript
    // Before: 숫자만 지원
    function add(a: number, c: number) {}

    // After: 배열 지원 (기능 구현 전 미리 변경)
    function add(a: number[]) {}
    ```

### Phase 1. 기초 공사 (Foundation)
**3. 타입(Type) 정의**
- 모든 구현의 기준이 되는 타입 파일을 가장 먼저 커밋합니다.
- **이유**: 컴포넌트, 함수 등 모든 코드의 기반이 되므로 가장 먼저 확정되어야 작업 순서가 깔끔해집니다.

**4. 단위 모듈 및 마크업 (Unit Level)**
- **특징**: 로직 없이 마크업만 있거나, 외부 의존성 없는 순수 함수. (유닛 테스트 가능)
- **작업 대상**:
  1. 공통 UI 컴포넌트 (도메인 비종속. 예: `Button`)
  2. 도메인 기초 UI 컴포넌트 (도메인 종속. 예: `BoardCard`)
  3. 유틸리티/포매팅 함수 (도메인 비종속, 예: `formatDate`)
  4. 상수 (도메인 종속, 예: `BOARD_FILTER_TYPES`)
  5. **상태별 UI** (Empty, Loading, Error 상태 등 마크업 미리 구현)
- **예시 (게시글 리스트 페이지)**:
  - `BoardCard` 컴포넌트 마크업 먼저 구현.
  - 게시글이 없을 때 보여줄 `EmptyContent` 컴포넌트 미리 구현.
  - 리스트/상세 등에서 공통으로 쓸 날짜 포매팅 함수 구현.
  - **효과**: 이렇게 엣지 케이스용 컴포넌트까지 미리 만들어두면, 나중에 API 연동 시 로직에만 집중할 수 있어 커밋이 깔끔해집니다.

### Phase 2. 통합 및 연동 준비 (Integration Level)
**5. 더미(Mock) 기반 통합 구현**
- **특징**: 실제 API 없이도 UI 흐름과 상호작용이 동작해야 합니다. (통합 테스트 가능)
- **작업 대상**:
  1. **Mock API**: 항상 성공하거나 실패하는 더미 데이터를 반환하는 함수 구현 (`getBoardListApi`).
  2. **Hooks**: 더미 데이터 / 더미콜백을 사용하는 `useQuery`나 폼 핸들러(`useForm`) 구현.
  3. **페이지/컨테이너 조립**: 앞서 만든 단위 컴포넌트들을 조합하여 페이지 완성.
  4. **유효성 검증**: 진입 시점의 데이터 검증 로직 구현.
- **예시 (게시글 리스트)**:
  - `getBoardListApi()`를 만들고 고정된 더미 데이터를 반환하게 함.
  - `/board/list?type=UNKNOWN` 접근 시 유효성 검증 로직 구현.
  - 데이터 유무에 따라 UI가 잘 노출되는지 확인 (데이터 로직은 다음 작업에서 연결).
- **예시 (게시글 수정)**:
  - `useBoardForm()` 훅을 만들고 `label`, `placeholder`, `onChange()` 등에 고정 값 / 콜백을 전달하여 폼 UI 확인.

### Phase 3. 실전 배치 (Implementation)
**6. API 연동 및 엣지 케이스 완성**
- **작업 대상**:
  1. Mock API를 **실제 API 호출**로 교체.
  2. 더미 데이터 제거.
  3. **API 에러 대응**: 4xx, 5xx 에러 발생 시 UI 처리 (Phase 1에서 만든 UI 활용).
  4. **성공/실패 분기 처리**: 데이터 유무에 따른 Empty 컴포넌트 노출 로직 연결.
- **예시**:
  - **성공**: 기존 더미 데이터 로직을 실제 API 응답으로 교체.
  - **실패**: API 실패 시(500 error), 이전에 만든 `ErrorComponent` 노출.
  - **엣지**: 리스트가 비어있을 경우, 이전에 만든 `EmptyContent` 노출.