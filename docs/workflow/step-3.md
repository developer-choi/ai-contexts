# Step 3: 핵심 과제 정의 및 기술 전략 수립
이 단계는 **하나의 PR**에 대한 핵심 기술적 과제를 정의하고, 최적의 도구(라이브러리)를 선정하는 단계입니다.

기획/디자인 부재 시 전반적인 UI/UX 컨셉도 확정하는 단계입니다.

## [CRITICAL] Step 2을 먼저 진행했나요?

다음 중 하나라도 해당되면 **Step 3이 아닌 [Step 2](./step-2.md)부터 진행**하세요:

1. **여러 PR로 나눠야 하는 큰 프로젝트**: 3개 이상의 페이지/컴포넌트가 영향을 받음
2. **공통 모듈 개발이 필요한 경우**: 여러 곳에서 재사용될 컴포넌트, 훅 등
3. **외부 협업이 필요한 경우**: 앱팀, 백엔드팀 등의 작업이 선행되어야 함
4. **단계적 배포가 필요한 경우**: 리스크 분산을 위해 기능을 나눠서 배포

**Step 2을 먼저 진행하면:**
- `/plan/project.md`에 전체 프로젝트 범위와 PR 분할 전략이 정리됨
- 각 PR별로 Step 3을 반복하며 `/plan/overview.md` 작성

---

## [CRITICAL] 진행 원칙: 단일 PR & 단일 기능
이 프로세스는 반드시 **한 번에 하나의 PR, 하나의 구체적인 기능**만 다뤄야 합니다.

1. **PR 단위**: 하나의 `overview.md`는 하나의 PR에 해당합니다.
2. **기능 세분화 (Feature Unit)**:
   - **❌ Bad (너무 큼)**: "게시판 CRUD 전체 개발해주세요."
   - **✅ Good (쪼개서 진행)**:
     - PR #1: "게시판 리스트 조회(R) 기능"
     - PR #2: "게시글 작성(C) 기능"
     - PR #3: "게시글 수정/삭제(U/D) 기능"
   - **이유**: 한 번에 너무 많은 기능을 다루면 리뷰와 테스트가 어려워집니다.

### 복수 기능/큰 프로젝트 요청 시 대응
사용자가 여러 기능이나 큰 범위를 요청하면:

1. **먼저 Step 2로 유도**:
   - "이 작업은 여러 PR로 나누는 것이 좋겠습니다. 먼저 Step 2에서 전체 범위와 PR 분할 전략을 정리할까요?"

2. **Step 2 완료 후**:
   - "Step 2에서 정리한 PR #1부터 시작하겠습니다. Step 3으로 진행할게요."

**범위 제한**: 하나의 `overview.md`는 하나의 PR, 하나의 세부 기능에 집중해야 합니다.

# 요청 내용
**[DOMAIN_NAME]** 도메인의 **[FEATURE]** 기능을 구현하려고 합니다.

전체 작업은 [계획 > 개발 > 리뷰] 순으로 진행되며, 지금은 첫 번째 **계획** 단계입니다.

[roadmap.md](../self-help/roadmap.md)의 사고 흐름을 적용하여 라이브러리 선정을 포함한 `/plan/overview.md`를 작성해주세요.

**단순한 기능 나열이 아닌, 논리적 흐름(문제 정의 -> 해결책 도출)과 라이브러리 선정의 타당성이 드러나야 합니다.**

---

## 작성 지침: 담백한 기능 중심 작성 (Keep It Simple)
- **간결함**: **"데스크톱 수준의 인터랙션", "능동적 제어 환경" 같은 화려한 수식어나 마케팅적 표현은 배제하세요.** 문서는 최대한 담백해야 합니다.
- **얕게 작성 (Shallow Overview)**: overview.md는 **간략한 개요 문서**입니다. 기획서의 내용을 모두 옮겨 단권화하지 마세요.
    - **기획서가 있는 경우**: 핵심 기능만 나열하고, 상세한 스펙은 기획서 참조
    - **기획서가 없는 경우**: 핵심 기술적 과제와 해결 방안만 간략히 작성
    - **이유**: 기획서와 동기화 유지가 어렵고, 문서가 너무 무거워지는 것을 방지

## 작성 양식 (`/plan/overview.md`)
### 1. 이 PR의 목표
> 프로젝트 전체 배경은 `/plan/background.md` 참조 (있는 경우)

- **이 PR에서 구현할 기능**: 이번 PR에서 구현할 기능만 나열
  - 예: 이벤트 페이지에 독려 모달 통합, 2주 재노출 로직

### 2. 핵심 기술적 과제 (Technical Challenges) - [선택적]
> **기획서가 있는 경우**: 기획서 참조. 필요 시 핵심 기술적 난제만 간략히 언급
>
> **기획서가 없는 경우**: 구현 시 기술적으로 고민이 필요한 부분만 작성

데이터 구조나 API 스펙 같은 명세는 작성하지 않습니다. **어떤 기술적 난제가 있는지만 나열**하세요.

#### 예시
- **과제 1**: 테이블 컬럼 너비 조절 기능 구현
- **과제 2**: 무한 스크롤 + 실시간 데이터 동기화
- **과제 3**: 복잡한 필터 조건 관리 및 상태 저장

**해결 방안(선택지 비교)은 Section 4에서 작성합니다.**

### 3. 디자인 및 레이아웃 컨셉 (Design Concept) - [선택적]
> **피그마가 있는 경우**: 피그마 링크만 참고 자료에 명시하고 생략
>
> **피그마가 없는 경우**: 전반적인 레이아웃 컨셉만 **간략히** 작성

#### 예시
- **레이아웃 구조**:
    - **Sidebar (좌측 고정)**: 상단 로고, 서비스 메뉴(Dashboard, Posts), 하단 사용자 프로필 요약.
    - **Header (상단 고정)**: 브레드크럼, 알림 아이콘, 테마 토글, 로그아웃 버튼.
    - **Main Content (본문)**: 페이지 타이틀, 액션 버튼(우측 상단), 데이터 테이블 또는 차트 영역.
- 모달 중심 인터랙션

### 4. 기술 전략 (Technical Strategy)

핵심 기술적 과제에 대한 **라이브러리 선정과 선택 근거**를 명시합니다.

각 과제마다 **여러 선택지를 비교**하고, **왜 특정 선택지를 선택했는지** 명확한 이유를 제시해야 합니다.

#### 작성 형식 (과제별)

각 주요 기술적 과제마다 아래 형식으로 작성:

---

**과제**: [기술적 과제 이름]

**선택지 1**: [라이브러리/접근법 이름]
- **장점**:
    - 장점 1
    - 장점 2
- **단점**:
    - 단점 1
    - 단점 2
- **적용 맥락**: 어떤 상황에 적합한가?

**선택지 2**: [다른 라이브러리/접근법]
- **장점**:
    - 장점 1
    - 장점 2
- **단점**:
    - 단점 1
    - 단점 2
- **적용 맥락**: 어떤 상황에 적합한가?

**선택지 3**: 직접 구현
- **장점**:
    - 완전한 제어 가능
    - 번들 사이즈 최소화
- **단점**:
    - 개발 시간 증가
    - 유지보수 부담
- **적용 맥락**: 매우 단순하거나 특수한 요구사항이 있을 때

**최종 선택**: [선택한 라이브러리/접근법]

**선택 이유**:
- 본 프로젝트의 요구사항 [X, Y, Z]를 고려했을 때, [선택한 라이브러리]가 가장 적합
- [구체적인 이유 1]: 예) 이미 프로젝트에서 사용 중이라 추가 학습 비용 없음
- [구체적인 이유 2]: 예) 무한 스크롤뿐 아니라 캐싱, 백그라운드 동기화까지 필요한데 이를 모두 지원
- [구체적인 이유 3]: 예) 팀 내 경험 있는 개발자가 많아 트러블슈팅 용이

---

#### 예시

**과제**: 무한 스크롤 구현

**선택지 1**: `@tanstack/react-query` (TanStack Query)
- **장점**:
    - useInfiniteQuery로 offset 기반 무한 스크롤 간편 구현
    - 캐싱, 백그라운드 리페칭, 낙관적 업데이트 등 강력한 기능
    - 로딩/에러 상태 자동 관리
    - 활발한 커뮤니티와 풍부한 레퍼런스
- **단점**:
    - 러닝 커브 존재 (쿼리 키 관리, 캐시 전략 이해 필요)
    - 번들 사이즈 약간 증가 (~12KB gzipped)
- **적용 맥락**: 복잡한 데이터 페칭과 상태 관리가 필요한 프로젝트

**선택지 2**: `swr`
- **장점**:
    - 매우 가벼운 번들 사이즈 (~5KB gzipped)
    - 단순하고 직관적인 API
    - Vercel에서 관리하는 안정적인 라이브러리
- **단점**:
    - 무한 스크롤 구현이 TanStack Query보다 복잡 (useSWRInfinite 사용)
    - 고급 캐싱 전략 부족
- **적용 맥락**: 단순한 데이터 페칭만 필요한 경우

**선택지 3**: 직접 구현 (useState + useEffect)
- **장점**:
    - 외부 의존성 없음
    - 완전한 제어 가능
- **단점**:
    - 캐싱, 리페칭, 중복 요청 방지 등 모든 로직 수동 구현 필요
    - 버그 발생 가능성 높음
    - 개발 시간 대폭 증가
- **적용 맥락**: 매우 단순한 페이지네이션만 필요한 경우

**최종 선택**: `@tanstack/react-query`

**선택 이유**:
- 본 프로젝트는 무한 스크롤뿐 아니라 **실시간 데이터 동기화**, **캐싱**, **낙관적 업데이트**가 모두 필요함
- 이미 프로젝트에서 TanStack Query를 사용 중이므로 추가 학습 비용 없음
- 검색/필터/정렬 조건 변경 시 자동으로 리페칭되는 기능이 필수인데, queryKey 기반 자동 리페칭으로 쉽게 구현 가능
- 팀원 모두 TanStack Query 경험이 있어 트러블슈팅과 코드 리뷰가 용이

---

**핵심 구현 방법은 작성하지 않습니다.** 어떤 도구를 왜 쓰는지, 무엇과 비교했는지만 명시하세요.

### 5. 참고 자료
> 기획서, 디자인, 회의록 링크는 `/plan/background.md` 참조

## [CRITICAL] 최종 검토: 기능 누락 확인
`overview.md` 작성이 완료되면, 반드시 다음을 수행하세요.

1. **대조 점검**: 처음에 제공받은 자료(기획서, 티켓, 요구사항 등)와 방금 작성한 `핵심 기능 목록`을 비교합니다.
2. **누락 확인**: 사용자가 요구했으나 문서에 포함되지 않은 기능이 있는지 확인합니다.
3. **수정 및 알림**: 누락된 기능이 있다면 문서를 수정하거나, 포함하지 않은 이유를 사용자에게 설명하세요.