# Step 3: 핵심 과제 정의 및 기술 전략 수립

이 단계는 **하나의 PR**에 대한 핵심 기술적 과제를 정의하고, 최적의 도구(라이브러리)를 선정하는 단계입니다.

> **[roadmap](docs/self-help/roadmap.md) 연결**: 2단계 - 선택지 탐색, 3단계 - 결정의 근거
>
> 바로 해결책을 제시하지 말고 **최소 2가지 이상의 대안**을 검토해야 합니다.
> 각 대안의 **장단점(성능, 개발 비용, 유지보수성, 리스크)**을 비교하고,
> **현재 프로젝트의 상황(데이터 성격, 트래픽 규모, 개발 리소스 등)**에 비추어
> 왜 이 기술이 최선인지 명확한 근거를 제시해야 합니다.

## 작성 지침: 담백한 기능 중심 작성 (Keep It Simple)
- **간결함**: **"데스크톱 수준의 인터랙션", "능동적 제어 환경" 같은 화려한 수식어나 마케팅적 표현은 배제하세요.** 문서는 최대한 담백해야 합니다.
- **얕게 작성 (Shallow Overview)**: /plan/overview.md는 **간략한 개요 문서**입니다. 기획서의 내용을 모두 옮겨 단권화하지 마세요.

---

## 작성 양식 (`/plan/overview.md`)

### 0. 참고 자료
- `/plan/background.md` (배경 파악 단계에서 생성됨)
- `/plan/codebase-audit.md` (PR 분할 전략 수립 단계에서 생성됨 - 있는 경우만)

### 1. 이 PR의 목표
- **이 PR에서 구현할 기능**: 이번 PR에서 구현할 기능만 나열
  - 예: 이벤트 페이지에 독려 모달 통합, 2주 재노출 로직

### 2. 디자인 및 레이아웃 컨셉 - [선택적]
> **피그마가 있는 경우**: 피그마 링크만 참고 자료에 명시하고 생략
>
> **피그마가 없는 경우**: 전반적인 레이아웃 컨셉만 **간략히** 작성

#### 예시
- **레이아웃 구조**:
  - **Sidebar (좌측 고정)**: 상단 로고, 서비스 메뉴(Dashboard, Posts), 하단 사용자 프로필 요약
  - **Header (상단 고정)**: 브레드크럼, 알림 아이콘, 테마 토글, 로그아웃 버튼
  - **Main Content (본문)**: 페이지 타이틀, 액션 버튼(우측 상단), 데이터 테이블 또는 차트 영역
- **인터랙션**: 모달 중심

### 3. 핵심 기술적 과제 및 기술 전략

구현 시 기술적으로 고민이 필요한 과제를 정의하고, 각 과제에 대한 **여러 선택지를 비교**합니다.

#### 작성 지침
1. **난제 정의**: 어떤 기술적 난제가 있는지 명확히 나열
2. **선택지 탐색**: 각 과제마다 **최소 2가지 대안** 검토
3. **장단점 비교**: 성능, 개발 비용, 유지보수성, 리스크 등을 구체적으로 비교
4. **결정 근거**: 프로젝트 맥락(데이터 특성, 트래픽, 팀 역량 등)을 반영한 선택 이유
5. **트레이드오프 명시**: 선택한 방안의 단점도 인정하고, 왜 그럼에도 불구하고 최선인지 설명

#### 선택 근거 작성 예시

**❌ Bad (기술만 나열)**
```
무한 스크롤 구현에 React Query를 사용하겠습니다.
```
문제: 왜 선택했는지, 다른 대안은 뭔지, 어떤 단점이 있는지 전혀 없음

**❌ Bad (맥락 없음)**
```
React Query vs SWR 비교했고, React Query가 기능이 많아서 선택했습니다.
```
문제: 프로젝트 상황, 팀 역량, 트레이드오프가 없음

**✅ Good (맥락 반영, 트레이드오프 명시)**
```
React Query vs SWR vs 직접 구현을 비교했습니다.

현재 프로젝트는:
- 복잡한 캐싱과 낙관적 업데이트 필요
- 검색/필터 조건 변경 시 자동 리페칭 필요
- 이미 프로젝트에서 React Query 사용 중

따라서 React Query를 선택합니다.

트레이드오프:
- 번들 사이즈가 SWR보다 크지만 (12KB vs 5KB), 이미 사용 중이므로 추가 비용 없음
- 러닝 커브가 있지만, 팀원 모두 경험 있어 학습 비용 없음
```

#### 예시

**과제**: 무한 스크롤 구현

**선택지 1**: `@tanstack/react-query` (TanStack Query)
- **장점**:
    - useInfiniteQuery로 offset 기반 무한 스크롤 간편 구현
    - 캐싱, 백그라운드 리페칭, 낙관적 업데이트 등 강력한 기능
    - 로딩/에러 상태 자동 관리
    - 활발한 커뮤니티와 풍부한 레퍼런스
- **단점**:
    - 러닝 커브 존재 (쿼리 키 관리, 캐시 전략 이해 필요)
    - 번들 사이즈 약간 증가 (~12KB gzipped)
- **적용 맥락**: 복잡한 데이터 페칭과 상태 관리가 필요한 프로젝트

**선택지 2**: `swr`
- **장점**:
    - 매우 가벼운 번들 사이즈 (~5KB gzipped)
    - 단순하고 직관적인 API
    - Vercel에서 관리하는 안정적인 라이브러리
- **단점**:
    - 무한 스크롤 구현이 TanStack Query보다 복잡 (useSWRInfinite 사용)
    - 고급 캐싱 전략 부족
- **적용 맥락**: 단순한 데이터 페칭만 필요한 경우

**선택지 3**: 직접 구현 (useState + useEffect)
- **장점**:
    - 외부 의존성 없음
    - 완전한 제어 가능
- **단점**:
    - 캐싱, 리페칭, 중복 요청 방지 등 모든 로직 수동 구현 필요
    - 버그 발생 가능성 높음
    - 개발 시간 대폭 증가
- **적용 맥락**: 매우 단순한 페이지네이션만 필요한 경우

**최종 선택**: `@tanstack/react-query`

**선택 근거 (프로젝트 맥락)**:
- **필수 요구사항 충족**: 본 프로젝트는 무한 스크롤뿐 아니라 실시간 데이터 동기화, 캐싱, 낙관적 업데이트가 모두 필요함
- **학습 비용**: 이미 프로젝트에서 TanStack Query를 사용 중이므로 추가 학습 비용 없음
- **기능적 필연성**: 검색/필터/정렬 조건 변경 시 자동 리페칭이 필수인데, queryKey 기반 자동 리페칭으로 쉽게 구현 가능
- **팀 역량**: 팀원 모두 TanStack Query 경험이 있어 트러블슈팅과 코드 리뷰가 용이
- **트레이드오프 수용**: 번들 사이즈가 SWR보다 크지만, 이미 사용 중이므로 추가 비용 없음. 러닝 커브가 있지만 팀이 이미 숙련됨.

**현재 상황에서 이 선택이 최선인 이유**:
- 다른 대안(SWR, 직접 구현)은 이미 도입된 도구를 교체하거나 추가 개발 비용을 발생시킴
- 프로젝트의 복잡도(실시간 동기화, 낙관적 업데이트)를 고려할 때 직접 구현은 리스크가 높음

---

**핵심 구현 방법은 작성하지 않습니다.** 어떤 도구를 왜 쓰는지, 무엇과 비교했는지, 프로젝트 맥락에서 왜 최선인지만 명시하세요.

## 최종 검토 체크리스트

- [ ] 제공받은 자료와 작성한 문서를 대조
- [ ] 사용자가 요구한 모든 기능이 포함되었는지 확인
- [ ] 누락된 기능이 있다면 수정하거나 포함하지 않은 이유 설명

---

## [CRITICAL] 다음 단계로 넘어가기 전 필수 확인

**⚠️ overview.md 작성을 완료한 후, 다음 단계(커밋 시퀀스 작성)로 넘어가기 전에 사용자 확인이 필요합니다.**

### AI의 필수 질문 (다음 단계 진행 전)

overview.md 작성을 완료한 후, 사용자에게 다음과 같이 물어보세요:

> "overview.md 작성이 완료되었습니다.
>
> 다음 단계(커밋 시퀀스 작성)로 넘어가기 전에 확인이 필요합니다.
>
> 다음 문서들을 모두 읽고 이해하셨나요?
> - `/plan/background.md` (배경 및 문제 정의)
> - `/plan/codebase-audit.md` (기존 코드 분석 - 있는 경우만)
> - `/plan/overview.md` (방금 작성한 기술 전략)
>
> **이해 안 되는 부분이나 애매한 부분이 있으신가요?**
>
> ⚠️ **모르는 부분이 있는 상태에서 다음 단계로 넘어가면, 커밋 계획부터 코드 작성까지 모든 단계에서 문제가 발생합니다.**
>
> 모든 내용을 이해하셨다면 승인해주세요. 다음 단계를 시작하겠습니다."