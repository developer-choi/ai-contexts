# Step 5: 상세 명세 작성 (Task Refinement)

이 단계는 `/plan/commit-sequence.md`에 정의된 각 커밋 단위 작업을 구체화하여 **최종 개발 명세서**를 완성하는 단계입니다.

> **[roadmap](docs/self-help/roadmap.md) 연결**: 4단계 - 구현의 여정
>
> 선택한 기술을 실제로 어떻게 적용했는지 설명합니다.
> - **구현 상세**: 구체적으로 어떻게 코드로 구현했는가?
> - **기술적 난관**: 구현 과정에서 마주친 엣지 케이스나 예상치 못한 문제는 무엇이었는가?

각 커밋에 대한 **상세 명세서**를 `/plan/tasks/` 폴더 아래에 생성해주세요.

**파일 명명 규칙**: `/plan/tasks/[순서]-[작업키워드].md` (예: `/plan/tasks/01-feat-button.md`)

---

## [CRITICAL] 필수 준수 사항

### 1. 진행 상황 동기화 (commit-sequence.md 업데이트)
- **상세 내용 삭제, 제목 유지**: 특정 커밋에 대한 상세 명세서(`tasks/*.md`) 작성이 완료되면, `/plan/commit-sequence.md`에서 해당 항목의 **하위 상세 작업 내용은 즉시 삭제**하세요.
- **제목(커밋 메시지)은 유지**: 어떤 단계의 설계가 완료되었는지 시각적으로 알 수 있도록 제목 라인만 남겨둡니다.

**업데이트 예시 (`commit-sequence.md`)**:

**❌ Bad (상세 내용이 그대로 남은 경우)**
```markdown
- [feat]: 네이티브 브릿지 타입 정의
  - 브릿지 메시지 타입 정의 (권한, 모달 정보)
  - 모달 닫힌 정보 타입 정의 (종류, 시각)
```

**✅ Good (상세 설계 완료 후 제목만 남기세요)**
```markdown
- [feat]: 네이티브 브릿지 타입 정의
```

### 2. 상세 스펙 작성 원칙 (로직 중심, 코드 배제)
- **[CRITICAL] 코드 블록(```) 사용 금지**: 변수명이나 함수명은 인라인 코드(\` \`)로 언급하되, 구현 코드를 통째로 작성하는 멀티라인 코드 블록은 작성하지 마세요.
- **논리적 서술**: "A 함수를 호출하여 B 값을 확인하고, 조건 C를 만족하면 D를 실행한다"와 같이 **자연어**나 **순서도(Flow)**로 로직을 설명하세요.
- **의도 명시**: "왜 이 로직이 필요한지", "어떤 엣지 케이스를 막아야 하는지"에 집중하세요.
- **예외 처리 보완**: 사용자가 제공한 정보를 그대로 복사하지 말고, 개발자 관점에서 누락된 예외 상황을 보완하세요.

### 3. 문서의 일회성
- **커밋 후 가치 소멸**: `tasks/*.md` 문서는 해당 커밋을 작성하기 위한 **임시 설계도**입니다.
- **최신화 불필요**: 코드가 커밋(`git commit`)된 이후에는, 실제 코드가 Source of Truth가 됩니다. 나중에 로직이 변경되더라도 이 문서를 다시 열어 수정(동기화)하지 마세요.

---

## 공통 작성 항목 (모든 작업 필수)

모든 작업 명세서는 다음 항목들을 반드시 포함해야 합니다.

### 1. 개요
- **작업 파일**: 생성 또는 수정할 파일의 경로 (예: `src/components/.../FileName.tsx`)
- **목적**: 이 작업이 왜 필요한지 세 줄 미만 요약.

### 2. 참고 자료
- 작업의 근거가 되는 문서 및 기존 코드를 링크합니다.
- **필수 포함**: `/plan/background.md`, `/plan/overview.md`, `/plan/commit-sequence.md`
- **추가 포함**: 관련된 기존 컴포넌트, 유틸리티, 또는 참고할 커밋 링크.

### 3. 예상 영향 범위
- **수정되는 파일**: 기존 코드를 수정해야 한다면 해당 파일 목록.
- **의존 관계**: 이 작업이 다른 컴포넌트/함수에 미치는 영향.

### 4. 핵심 로직 설계 (Core Logic Design)
- **[CRITICAL] 실제 코드 작성 금지**: `const`, `function`, `async/await`, `useCallback` 등 실제 구현 코드를 절대 작성하지 마세요.
- 대신 **의사 코드(Pseudo-code)**, **논리적 단계(Flow)**, 또는 **텍스트 서술**을 통해 로직의 흐름과 호출할 메서드만 기술하세요.
- 개발자가 구현 방식(How)을 고민하게 하는 것이 아니라, 수행해야 할 논리(What)를 전달하는 것이 목적입니다.

**❌ Bad (실제 코드 작성 - 금지)**
```typescript
const handleAccept = async () => {
  const status = await notification.checkPermission();
  if (status === 'GRANTED') {
    toggleNotification('PROMOTION', true);
  }
};
```

**✅ Good (로직 흐름 서술 - 권장)**
1. `notification.checkPermission()` 호출하여 권한 상태 확인
2. **GRANTED 상태인 경우**:
   - `toggleNotification('PROMOTION', true)` API 호출
   - 성공 토스트 노출 (포맷: `... (${dayjs().format('YYYY.MM.DD')})`)
   - `onAccept()` 호출하여 모달 닫기
3. **그 외 상태인 경우**:
   - `onOpenNotificationPermissionModal()` 호출하여 기기 설정 유도 모달 오픈

---

## 작업 유형별 템플릿

각 작업의 성격에 따라 아래 템플릿을 참고하여 **유형별 특화 항목**을 추가하세요.

### 1. 컴포넌트 개발인 경우
**추가 필수 항목**: Props Interface, 데이터 표시 형식, UX 워크플로우, 상태 피드백, 스타일링 & 엣지 케이스

**템플릿**: [`./template/component.md`](./template/component.md)

### 2. 함수 / 훅 / 클래스 개발인 경우
**추가 필수 항목**: 모듈/함수 시그니처, 핵심 로직, 예외 처리

**템플릿**: [`./template/function-hooks-class.md`](./template/function-hooks-class.md)

---

## 작성 시 주의사항

1. **중복 방지**: 사용자가 제공한 정보를 단순 복사하지 말고, 개발자가 필요로 하는 형태로 재구성
2. **구체성**: "적절히 처리", "필요시 추가" 같은 모호한 표현 금지
3. **완결성**: 한 명세서만으로 개발 완료 가능하도록 모든 정보 포함
