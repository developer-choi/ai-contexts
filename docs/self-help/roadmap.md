# 문제 해결 로드맵: Beyond Solving Problem

## 경험 재구성 5단계

그 문제가 왜 발생했는지 진짜 원인(Root Cause)을 찾아야 합니다.

그다음, 왜 그 방법을 선택했는지를 성과로 제시해야 합니다.

---

### 1단계 문제의 발견과 근본 원인 (Deep Dive)
단순히 "로딩이 느리다"와 같은 현상은 문제가 아닙니다. 그것은 **증상(Symptom)**입니다.
우리의 목표는 증상을 덮는 것이 아니라, 병의 **근본 원인(Root Cause)**을 찾아내는 것입니다.

#### 1-1. 문제 정의 (증상과 영향)
* **증상(Phenomenon):** 기대와 다르게 동작하는 현상은 무엇인가? (예: 옵션이 유지되지 않음, 간헐적 CORS 에러)
* **발견 경로:** 어떻게 이 문제를 인지했는가? (로그, 모니터링, VOC 등)
* **비즈니스 임팩트:** 이 문제가 왜 해결되어야 하는가?

#### 1-2. 원인 추적 및 검증 (Troubleshooting & Deep Dive)
문제를 해결하는 것보다 중요한 것은 **"문제를 좁혀나가는 논리적 과정"**입니다.
마치 수사관처럼 용의선(가능성)을 하나씩 배제하며 범인(원인)을 찾아내야 합니다.

* **범위 좁히기 (Narrowing Down):**
  * "어디서부터 어디까지는 정상인가?"를 확인했는가?
  * *Network 레벨인가? Application Logic인가? DB인가?*
  * *특정 브라우저 문제인가? 특정 OS 문제인가?*
  * *내 코드 문제인가? 라이브러리 버그인가?*

* **Deep Dive 예시 (표면적 원인 vs 근본적 원인):**
  * **❌ Bad (현상적 접근):**
    * "API가 계속 2번 호출되길래 확인해보니 `useEffect` 의존성 배열에 객체가 들어있었다. 그래서 `JSON.stringify`로 비교하게 바꿨더니 해결됐다." (해결책에만 집중)
  * **✅ Good (원리적 접근):**
    * "JS에서 객체는 참조(Reference) 타입이므로, 컴포넌트가 리렌더링될 때마다 새로운 메모리 주소를 가진 객체가 생성된다.
    * React의 `useEffect`는 의존성 배열을 **얕은 비교(Shallow Compare)**하기 때문에, 내용이 같아도 참조가 다르면 변경된 것으로 인식한다.
    * 따라서 단순 비교가 아닌, **참조 무결성**을 보장하기 위해 `useMemo`를 사용하거나, 불필요한 객체 생성을 컴포넌트 외부로 격리하여 렌더링 사이클과 분리했다."

#### 1-3. 시니어(면접관)의 압박 질문 방어 (Defense)
여러분이 찾은 원인이 '진짜'인지 검증하기 위해 가상의 까다로운 시니어가 되어 질문을 던져보세요.

> 🕵️ **Senior Developer:**
> * "그게 진짜 원인이라고 **100% 확신**하나요? 다른 변수는 완벽히 통제되었나요?"
> * "해결된 건 알겠는데, **정확히 어떤 원리**로 해결된 거죠? 우연히 타이밍이 맞은 건 아닌가요?"
> * "그 라이브러리 내부에서는 해당 로직을 어떻게 처리하고 있나요? 소스 코드는 까보셨나요?"
> * "이 문제는 **재현 가능(Reproducible)**한가요? 테스트 코드로 증명할 수 있나요?"

---

### 2단계 선택지 탐색
바로 해결책을 제시하지 말고 최소 2가지 이상의 대안을 검토해야 합니다.

> 이후 각 대안의 장단점(성능, 개발 비용, 유지보수성, 리스크)을 비교해야 합니다.

* **옵션 A:** 인프라/플랫폼 레벨의 해결 (예: CDN, 캐시 서버 도입)
* **옵션 B:** 애플리케이션 로직 최적화 (예: 알고리즘 개선, 비동기 처리)
* **옵션 C:** 아키텍처 변경 또는 근본적 리팩토링

---

### 3단계 결정의 근거
남들이 많이 써서는 올바른 근거가 아닙니다.

> 현재 프로젝트의 상황(데이터 성격, 트래픽 규모, 개발 리소스 등)에 비추어 볼 때 왜 이 기술이 최선이었는가?

---

### 4단계 구현의 여정
선택한 기술을 실제로 어떻게 적용했는지 설명합니다.

* **구현 상세:** 구체적으로 어떻게 코드로 구현했는가?
* **기술적 난관:** 구현 과정에서 마주친 엣지 케이스나 예상치 못한 문제는 무엇이었는가?

---

### 5단계 결과와 학습
> 막연한 개선이 아닌 증명 가능한 성과를 제시합니다.

* **수치 증명:** 성능이 개선되었다면 정확히 어떤 지표(TPS, 응답 시간, 렌더링 속도 등)가 얼마나 변했는가?
* **학습:** 이 경험을 통해 무엇을 배웠는가?

---

## 꼬리 질문 방어와 심화 검증

검증 질문은 논리의 빈틈을 파고듭니다. 다음 패턴에 대한 방어 논리를 미리 구축하십시오.

### 필수 방어 질문 리스트
* **선택의 이유:** 왜 하필 그 기술인가? 다른 대안(DB 튜닝 등)은 고려하지 않았는가?
* **필연성 강조:** 상황적 제약과 트레이드오프 때문에 이 기술을 써야만 했다는 논리로 접근하십시오.
* **부작용 체크:** 기술 도입 후 성능이 저하되거나 운영 복잡도가 늘어난 부분은 없었는가?
* **장애 대응:** 운영 중 발생한 문제는 없었으며, 있었다면 어떻게 해결했는가?

### 기술적 원리 이해
단순 사용 경험을 넘어 기술의 내부 동작 원리를 설명할 수 있어야 합니다.

* **백엔드:** 인덱스(커버링 인덱스 등) 원리, 트랜잭션 격리 수준, 동시성 제어(락).
* **프론트엔드:** 브라우저 렌더링 원리, 상태 관리의 구조, 번들링 최적화 원리 등.

---

## 출처
- [대기업 기술면접 준비 가이드](https://www.youtube.com/watch?v=x__FGE5UNe8)
- [카카오엔터테인먼트 문제 해결을 넘어 - 문제의 근본적인 원인 찾아가기 Part 1](https://tech.kakaoent.com/front-end/2023/230420-beyond-solving-problem-part-1/)